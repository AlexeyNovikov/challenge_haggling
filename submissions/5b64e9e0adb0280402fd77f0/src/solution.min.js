const __exports={},define=function(t,e,s){const r=[null,__exports[t]={}];for(let t=2;t<e.length;t++)r.push(__exports[e[t]]);s.apply(null,r)};var Order;!function(t){t[t.Asc=0]="Asc",t[t.Desc=1]="Desc"}(Order||(Order={})),Array.prototype.orderBy=function(...t){return this.sort((e,s)=>{for(let r of t){const t=r.selector(e),i=r.selector(s);if(r.order===Order.Asc&&t>i||r.order===Order.Desc&&t<i)return 1;if(r.order===Order.Asc&&t<i||r.order===Order.Desc&&t>i)return-1}return 0})},Array.prototype.equal=function(t){if(this.length!==t.length)return!1;for(let e=0;e<this.length;e++)if(this[e]!==t[e])return!1;return!0},define("solution",["require","exports","./array"],function(t,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class s{constructor(t,e){this.me=t,this.offer=e}}class r{constructor(t,e,s){this.counts=t,this.value=e,this.p=s,this.count=t.reduce((t,e)=>t+e)}}const i=(t,e)=>(t=Math.ceil(t),e=Math.floor(e),Math.floor(Math.random()*(e-t+1))+t);module.exports=class{constructor(t,e,s,r,i){this.counts=e,this.values=s,this.max_rounds=r,this.log=i,this.round=0,this.history=[],this.myFirstP=.9,this.myLastButOneP=.6,this.myLastP=.2,this.rivalFirstP=.9,this.rivalLastP=.4,this.epsilonP=.05,this.me=0===t,this.length=e.length,this.totalValue=this.getValue(e,s),this.allOffers=this.getAllOffers(),this.allRivalValues=this.getAllRivalValues(),this.myProbabilities=this.getMyProbabilities(),this.rivalProbabilities=this.getProbabilities(this.rivalFirstP,this.rivalLastP,this.max_rounds)}getValue(t,e=this.values){return t.reduce((t,s,r)=>t+s*e[r],0)}getAllOffers(){const t=[];return this.setNextOffers(new Array,0,t),t.orderBy({order:Order.Desc,selector:t=>t.value}),t}setNextOffers(t,e,s){for(let i=0;i<=this.counts[e];i++){if(t[e]=i,t.fill(0,e+1),e===this.length-1){const e=t.slice(),i=this.getValue(e),l=this.getP(i);s.push(new r(e,i,l))}e+1<this.length&&this.setNextOffers(t,e+1,s)}}getAllRivalValues(){const t=[];return this.setNextRivalValues(new Array(this.length),0,t),t}setNextRivalValues(t,e,s){for(let r=0;r<=this.totalValue;r++){t[e]=r,t.fill(0,e+1);const i=this.getValue(this.counts,t);if(i>this.totalValue)break;i===this.totalValue&&e===this.length-1&&s.push(t.slice()),e+1<this.length&&this.setNextRivalValues(t,e+1,s)}}getMyProbabilities(){const t=this.getProbabilities(this.myFirstP,this.myLastButOneP,this.max_rounds-1);return t.push(this.myLastP),t}getProbabilities(t,e,s=this.max_rounds){const r=(e-t)/(s-1),i=[];for(let e=0;e<s;e++)i.push(t+r*e);return i}getP(t){return t/this.totalValue}inverse(t){return t.map((t,e)=>this.counts[e]-t)}getRivalCountStatistics(){const t=this.history.filter(t=>!t.me),e=new Array(this.length);e.fill(0);for(let s of t)for(let t=0;t<this.length;t++)e[t]+=s.offer[t];for(let s=0;s<this.length;s++)e[s]=e[s]/t.length;return e}valuesCount(t){return t.reduce((t,e)=>t+e>0?1:0,0)}excludeFreeCounts(t){return t.filter(t=>!t.counts.some((t,e)=>t>0&&0===this.values[e]))}excludeEverything(t){return t.filter(t=>!t.counts.equal(this.counts))}getAvailableOffers(){let t=this.excludeFreeCounts(this.allOffers);t.length>1&&(t=this.excludeEverything(t));let e=this.myProbabilities[this.round];return e>t[0].p&&(e=t[0].p-this.epsilonP),t.filter(t=>t.p>=e)}diff(t,e){return t.reduce((t,s,r)=>t+Math.pow(s-e[r],2),0)}findFirstOffer(){let t=this.allOffers.filter(t=>t.p>=1);if(t.length>1)t=this.excludeEverything(this.excludeFreeCounts(t));else{const e=(t=this.excludeFreeCounts(this.allOffers)).filter(t=>t.p>=this.myFirstP&&t.p<1);e.length>0&&(t=e)}return t[i(0,t.length-1)].counts}findOffer(){let t=this.getAvailableOffers();if(this.history.filter(t=>!t.me).length>0){const e=this.getRivalCountStatistics(),s=(e.map((t,e)=>t/this.counts[e]),this.allRivalValues.map(t=>{const s=this.getValue(e,t);return new class{constructor(t,e,s){this.values=t,this.value=e,this.p=s}}(t,s,this.getP(s))}));s.orderBy({order:Order.Desc,selector:t=>t.value},{order:Order.Desc,selector:t=>this.valuesCount(t.values)});const r=s[0].values,i=t.map(t=>{const s=this.inverse(t.counts),i=this.getValue(s,r);return{offer:t,rivalValue:i,rivalP:this.getP(i),diff:this.diff(s,e)}});i.orderBy({order:Order.Desc,selector:t=>t.rivalValue},{order:Order.Desc,selector:t=>t.offer.value},{order:Order.Asc,selector:t=>t.offer.count});let l=i[0];const o=this.rivalProbabilities[this.round],h=i.filter(t=>t.rivalP>=o);return h.length>0&&(h.orderBy({order:Order.Desc,selector:t=>t.offer.value},{order:Order.Asc,selector:t=>t.offer.count}),l=h[0]),l.offer.counts}return t[i(0,t.length-1)].counts}checkOffer(t){const e=this.getValue(t),s=this.me&&this.round>=this.max_rounds-1?.4:this.myProbabilities[this.round];return this.getP(e)>=s}offer(t){let e;if(void 0===t)e=this.findFirstOffer();else{if(this.history.push(new s(!1,this.inverse(t))),this.checkOffer(t))return;e=this.findOffer()}return this.history.push(new s(!0,e)),this.round++,e}}});